/**
 * Composition Schema Types
 * 
 * Defines the output structure for the AI Pattern Composer.
 * The composer selects and combines modular patterns into complete page compositions.
 */

// ============================================================================
// Core Composition Types
// ============================================================================

export interface PageComposition {
  pageId: string;
  path: string;
  layout: LayoutType;
  sections: SectionComposition[];
}

export type LayoutType = 
  | "layout-marketing"
  | "layout-dashboard"
  | "layout-blog"
  | "layout-ecommerce"
  | "layout-minimal";

export interface SectionComposition {
  patternId: string;                 // e.g., "hero-split-image"
  variant: string;                   // e.g., "dark", "light", "gradient"
  order: number;
  props: Record<string, unknown>;    // AI-generated props
  customizations?: SectionCustomizations;
  isCustomGenerated?: boolean;       // True if generated by gap-filler
}

export interface SectionCustomizations {
  className?: string;
  style?: Record<string, string>;
  animations?: AnimationConfig;
}

export interface AnimationConfig {
  type: "fade" | "slide" | "scale" | "none";
  delay?: number;
  duration?: number;
}

// ============================================================================
// Project-Level Composition
// ============================================================================

export interface ProjectComposition {
  projectId: string;
  pages: PageComposition[];
  globalStyles: GlobalStyles;
  sharedComponents: string[];        // Patterns used across pages
  metadata: CompositionMetadata;
}

export interface GlobalStyles {
  colorScheme: ColorScheme;
  fontFamily: FontConfig;
  borderRadius: BorderRadiusScale;
  spacing: SpacingScale;
}

export interface ColorScheme {
  primary: string;
  secondary: string;
  accent: string;
  background: string;
  foreground: string;
  muted: string;
}

export interface FontConfig {
  heading: string;
  body: string;
  mono?: string;
}

export type BorderRadiusScale = "none" | "sm" | "md" | "lg" | "xl" | "full";
export type SpacingScale = "compact" | "comfortable" | "spacious";

export interface CompositionMetadata {
  createdAt: string;
  version: string;
  confidence: number;
  generationTime: number;
}

// ============================================================================
// Composer Input Types
// ============================================================================

export interface ComposerInput {
  vision: VisionDocument;
  research?: ResearchResult;
  template: TemplateType;
  pages: PageConfig[];
  integrations: Record<string, string>;
  preferences?: ComposerPreferences;
}

export interface VisionDocument {
  projectName: string;
  description: string;
  audience?: string;
  tone?: ToneType;
  goals?: string[];
  keywords?: string[];
  competitors?: string[];
}

export type ToneType = 
  | "professional"
  | "friendly"
  | "playful"
  | "luxurious"
  | "technical"
  | "casual";

export interface ResearchResult {
  domain?: string;
  insights: string[];
  recommendations: ResearchRecommendation[];
  competitorAnalysis?: CompetitorInsight[];
  targetAudience?: string;
  extractedContent?: string;
}

export interface ResearchRecommendation {
  category: string;
  features: string[];
  reason: string;
}

export interface CompetitorInsight {
  name: string;
  strengths: string[];
  patterns: string[];
}

export type TemplateType = 
  | "saas"
  | "ecommerce"
  | "blog"
  | "portfolio"
  | "landing"
  | "dashboard"
  | "directory";

export interface PageConfig {
  path: string;
  name: string;
  type: PageType;
  priority?: number;
}

export type PageType =
  | "home"
  | "about"
  | "pricing"
  | "features"
  | "blog"
  | "blog-post"
  | "contact"
  | "product"
  | "dashboard"
  | "settings"
  | "auth";

export interface ComposerPreferences {
  maxSections?: number;
  preferPatterns?: string[];
  avoidPatterns?: string[];
  customInstructions?: string;
  generateImages?: boolean;
}

// ============================================================================
// Composer Output Types
// ============================================================================

export interface ComposerOutput {
  composition: ProjectComposition;
  reasoning: PatternReasoning[];
  confidence: number;                // 0-100
  warnings?: string[];
}

export interface PatternReasoning {
  patternId: string;
  pageId: string;
  reason: string;
  alternatives?: string[];
  confidenceScore: number;
}

// ============================================================================
// Pattern Types (for integration with Pattern Registry)
// ============================================================================

export interface Pattern {
  id: string;
  name: string;
  category: PatternCategory;
  variants: string[];
  slots: PatternSlot[];
  tags: string[];
  previewImage?: string;
}

export type PatternCategory =
  | "hero"
  | "features"
  | "pricing"
  | "testimonials"
  | "cta"
  | "faq"
  | "footer"
  | "navigation"
  | "blog"
  | "product"
  | "stats"
  | "team";

export interface PatternSlot {
  name: string;
  type: "text" | "richText" | "image" | "array" | "boolean" | "number";
  required: boolean;
  description?: string;
  maxLength?: number;
  defaultValue?: unknown;
}

// ============================================================================
// Selection Types (for Pattern Selector AI)
// ============================================================================

export interface PatternSelection {
  patternId: string;
  reason: string;
  variant: string;
  order: number;
  confidenceScore: number;
}

export interface SelectorInput {
  vision: VisionDocument;
  research?: ResearchResult;
  designAnalysis?: import('../design-analyzer').DesignAnalysis;
  availablePatterns: Pattern[];
  pageType: PageType;
  existingSections?: SectionComposition[];
}

export interface SelectorOutput {
  sections: PatternSelection[];
  layoutRecommendation: LayoutType;
}

// ============================================================================
// Prop Generation Types
// ============================================================================

export interface PropGeneratorInput {
  pattern: Pattern;
  context: ComposerInput;
  sectionIndex: number;
}

export interface PropGeneratorOutput {
  props: Record<string, unknown>;
  tokensUsed: number;
}

// ============================================================================
// Gap Filler Types
// ============================================================================

export interface GapFillerInput {
  requirement: string;
  context: ComposerInput;
  existingPatterns: Pattern[];
  surroundingSections: SectionComposition[];
}

export interface GapFillerOutput {
  component: string;               // Generated React code
  props: Record<string, unknown>;
  patternId: string;               // Custom ID like "custom-{hash}"
}

