/**
 * Feature Loader
 * 
 * Loads feature templates and resolves dependencies for code generation.
 * Bridges between UI feature selection and template file system.
 */

import { GeneratedFile, FeatureManifest, FeatureCategory } from "./types";
import { FEATURES, getFeatureById } from "../features";

// Feature template file contents - embedded for browser compatibility
// These map to templates/features/{category}/{feature-id}/
const FEATURE_TEMPLATES: Record<string, Record<string, string>> = {};

/**
 * Resolve dependencies for selected features
 * Returns all features including transitive dependencies
 */
export function resolveFeatureDependencies(selectedFeatures: string[]): string[] {
  const resolved = new Set<string>();
  const queue = [...selectedFeatures];

  while (queue.length > 0) {
    const featureId = queue.shift()!;
    if (resolved.has(featureId)) continue;

    const feature = getFeatureById(featureId);
    if (!feature) {
      console.warn(`Unknown feature: ${featureId}`);
      continue;
    }

    // Add dependencies to queue first (to process in order)
    for (const dep of feature.dependencies) {
      if (!resolved.has(dep)) {
        queue.unshift(dep);
      }
    }

    resolved.add(featureId);
  }

  return Array.from(resolved);
}

/**
 * Get all template files for selected features
 */
export function getFeatureFiles(
  selectedFeatures: string[],
  options: { projectName?: string } = {}
): {
  files: GeneratedFile[];
  packages: Record<string, string>;
  devPackages: Record<string, string>;
  envVars: { name: string; description: string; required: boolean; example?: string }[];
} {
  const { projectName = "my-project" } = options;
  const resolvedFeatures = resolveFeatureDependencies(selectedFeatures);

  const files: GeneratedFile[] = [];
  const packages: Record<string, string> = {};
  const devPackages: Record<string, string> = {};
  const envVars: { name: string; description: string; required: boolean; example?: string }[] = [];

  // Track which env vars we've added to avoid duplicates
  const addedEnvVars = new Set<string>();

  for (const featureId of resolvedFeatures) {
    const feature = getFeatureById(featureId);
    if (!feature) continue;

    // Get the template content for each code template file
    for (const templatePath of feature.codeTemplates) {
      const content = getTemplateContent(featureId, templatePath, projectName);
      if (content) {
        files.push({
          path: templatePath,
          content,
          overwrite: false,
        });
      }
    }

    // Add dependencies based on feature
    const deps = getFeatureDependencies(featureId);
    Object.assign(packages, deps.npm);
    Object.assign(devPackages, deps.npmDev);

    // Add env vars
    for (const envVar of deps.envVars) {
      if (!addedEnvVars.has(envVar.name)) {
        envVars.push(envVar);
        addedEnvVars.add(envVar.name);
      }
    }
  }

  return { files, packages, devPackages, envVars };
}

/**
 * Get template content for a feature file
 */
function getTemplateContent(featureId: string, templatePath: string, projectName: string): string | null {
  // Try to get from embedded templates first
  const embedded = FEATURE_TEMPLATES[featureId]?.[templatePath];
  if (embedded) {
    return applyPlaceholders(embedded, projectName);
  }

  // Generate placeholder template if not embedded
  return generatePlaceholderTemplate(featureId, templatePath, projectName);
}

/**
 * Generate a placeholder template for a feature file
 * This provides minimal working code when full templates aren't available
 */
function generatePlaceholderTemplate(featureId: string, templatePath: string, projectName: string): string {
  const feature = getFeatureById(featureId);
  const fileName = templatePath.split("/").pop() || "";
  const isComponent = templatePath.includes("components/") || fileName.endsWith(".tsx");
  const isPage = templatePath.includes("app/") && templatePath.endsWith("page.tsx");
  const isRoute = templatePath.includes("app/api/") && templatePath.endsWith("route.ts");
  const isLib = templatePath.includes("lib/");
  const isHook = fileName.startsWith("use") || templatePath.includes("hooks/");

  // Component template
  if (isComponent && !isPage) {
    const componentName = fileName.replace(".tsx", "");
    return `/**
 * ${componentName} Component
 * Feature: ${feature?.label || featureId}
 * 
 * Auto-generated by ${projectName}
 */

"use client";

import { useState } from "react";

interface ${componentName}Props {
  className?: string;
}

export function ${componentName}({ className = "" }: ${componentName}Props) {
  return (
    <div className={\`\${className}\`}>
      <p className="text-gray-500">${componentName} - Implement your ${feature?.label || featureId} UI here</p>
    </div>
  );
}
`;
  }

  // Page template
  if (isPage) {
    const pageName = templatePath.split("/").slice(-2, -1)[0] || featureId;
    return `/**
 * ${pageName} Page
 * Feature: ${feature?.label || featureId}
 * 
 * Auto-generated by ${projectName}
 */

export default function ${capitalize(pageName)}Page() {
  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-6">${feature?.label || capitalize(pageName)}</h1>
      <p className="text-gray-600">
        This page was generated for the ${feature?.label || featureId} feature.
        Customize it to fit your needs.
      </p>
    </div>
  );
}
`;
  }

  // API route template
  if (isRoute) {
    return `/**
 * API Route
 * Feature: ${feature?.label || featureId}
 * 
 * Auto-generated by ${projectName}
 */

import { NextRequest, NextResponse } from "next/server";

export async function GET(request: NextRequest) {
  // TODO: Implement ${feature?.label || featureId} logic
  return NextResponse.json({ message: "API endpoint ready" });
}

export async function POST(request: NextRequest) {
  const body = await request.json();
  // TODO: Implement ${feature?.label || featureId} logic
  return NextResponse.json({ success: true });
}
`;
  }

  // Hook template
  if (isHook) {
    const hookName = fileName.replace(".ts", "").replace(".tsx", "");
    return `/**
 * ${hookName} Hook
 * Feature: ${feature?.label || featureId}
 * 
 * Auto-generated by ${projectName}
 */

"use client";

import { useState, useCallback } from "react";

export function ${hookName}() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  // TODO: Implement ${feature?.label || featureId} logic

  return {
    loading,
    error,
  };
}
`;
  }

  // Library/utility template
  if (isLib) {
    const libName = fileName.replace(".ts", "").replace(".tsx", "");
    return `/**
 * ${libName}
 * Feature: ${feature?.label || featureId}
 * 
 * Auto-generated by ${projectName}
 */

// TODO: Implement ${feature?.label || featureId} utilities

export interface ${capitalize(libName)}Config {
  // Add configuration options
}

export async function initialize${capitalize(libName)}(config: ${capitalize(libName)}Config) {
  // TODO: Initialize ${feature?.label || featureId}
  console.log("${libName} initialized");
}
`;
  }

  // Default template
  return `/**
 * ${fileName}
 * Feature: ${feature?.label || featureId}
 * 
 * Auto-generated by ${projectName}
 * Implement your ${feature?.label || featureId} logic here.
 */

// TODO: Implement ${feature?.label || featureId}
`;
}

/**
 * Get npm dependencies for a feature
 */
function getFeatureDependencies(featureId: string): {
  npm: Record<string, string>;
  npmDev: Record<string, string>;
  envVars: { name: string; description: string; required: boolean; example?: string }[];
} {
  const deps: Record<string, string> = {};
  const devDeps: Record<string, string> = {};
  const envVars: { name: string; description: string; required: boolean; example?: string }[] = [];

  // Map features to their required packages
  switch (featureId) {
    case "shopping-cart":
    case "wishlist":
      deps["zustand"] = "^4.5.0";
      break;

    case "price-tracking":
    case "charts-visualization":
    case "reports":
    case "conversion-funnels":
      deps["recharts"] = "^2.10.0";
      break;

    case "full-text-search":
      // Uses built-in Supabase full-text search
      break;

    case "social-login":
      envVars.push(
        { name: "GOOGLE_CLIENT_ID", description: "Google OAuth client ID", required: false, example: "your-google-client-id" },
        { name: "GOOGLE_CLIENT_SECRET", description: "Google OAuth client secret", required: false, example: "your-google-secret" },
        { name: "GITHUB_CLIENT_ID", description: "GitHub OAuth client ID", required: false, example: "your-github-client-id" },
        { name: "GITHUB_CLIENT_SECRET", description: "GitHub OAuth client secret", required: false, example: "your-github-secret" }
      );
      break;

    case "subscription-billing":
    case "one-time-payments":
      deps["stripe"] = "^14.0.0";
      envVars.push(
        { name: "STRIPE_SECRET_KEY", description: "Stripe secret key", required: true, example: "sk_test_..." },
        { name: "STRIPE_WEBHOOK_SECRET", description: "Stripe webhook signing secret", required: true, example: "whsec_..." },
        { name: "NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY", description: "Stripe publishable key", required: true, example: "pk_test_..." }
      );
      break;

    case "shipping-integration":
      envVars.push(
        { name: "SHIPPO_API_KEY", description: "Shippo API key for shipping rates", required: false, example: "shippo_test_..." }
      );
      break;

    case "rate-limiting":
      deps["@upstash/ratelimit"] = "^1.0.0";
      deps["@upstash/redis"] = "^1.27.0";
      envVars.push(
        { name: "UPSTASH_REDIS_REST_URL", description: "Upstash Redis URL", required: false },
        { name: "UPSTASH_REDIS_REST_TOKEN", description: "Upstash Redis token", required: false }
      );
      break;

    // Marketplace features
    case "user-listings":
    case "auction-bidding":
    case "seller-profiles":
    case "marketplace-transactions":
      deps["lucide-react"] = "^0.400.0";
      // Uses built-in Supabase for database and realtime
      break;
  }

  return { npm: deps, npmDev: devDeps, envVars };
}

/**
 * Apply project-specific placeholders to template content
 */
function applyPlaceholders(content: string, projectName: string): string {
  return content
    .replace(/\{\{projectName\}\}/g, projectName)
    .replace(/\{\{PROJECT_NAME\}\}/g, projectName.toUpperCase().replace(/\s+/g, "_"))
    .replace(/\{\{project_name\}\}/g, projectName.toLowerCase().replace(/\s+/g, "-"));
}

/**
 * Capitalize first letter
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1).replace(/-./g, (x) => x[1].toUpperCase());
}

/**
 * Get feature summary for display
 */
export function getFeatureSummary(selectedFeatures: string[]): {
  totalFeatures: number;
  byCategory: Record<FeatureCategory, number>;
  dependencies: string[];
  packages: string[];
  estimatedFiles: number;
} {
  const resolved = resolveFeatureDependencies(selectedFeatures);
  const byCategory: Record<FeatureCategory, number> = {
    "user-management": 0,
    "product-database": 0,
    "search-filter": 0,
    "ecommerce": 0,
    "marketplace": 0,
    "analytics": 0,
    "billing": 0,
    "enterprise": 0,
  };

  let estimatedFiles = 0;
  const packagesSet = new Set<string>();

  for (const featureId of resolved) {
    const feature = getFeatureById(featureId);
    if (feature) {
      byCategory[feature.category]++;
      estimatedFiles += feature.codeTemplates.length;

      const deps = getFeatureDependencies(featureId);
      Object.keys(deps.npm).forEach((p) => packagesSet.add(p));
    }
  }

  return {
    totalFeatures: resolved.length,
    byCategory,
    dependencies: resolved.filter((f) => !selectedFeatures.includes(f)),
    packages: Array.from(packagesSet),
    estimatedFiles,
  };
}

/**
 * Validate feature selection
 */
export function validateFeatureSelection(selectedFeatures: string[]): {
  valid: boolean;
  errors: string[];
  warnings: string[];
} {
  const errors: string[] = [];
  const warnings: string[] = [];

  for (const featureId of selectedFeatures) {
    const feature = getFeatureById(featureId);

    if (!feature) {
      errors.push(`Unknown feature: ${featureId}`);
      continue;
    }

    // Check dependencies
    for (const dep of feature.dependencies) {
      if (!selectedFeatures.includes(dep)) {
        warnings.push(`Feature "${feature.label}" requires "${dep}" (will be auto-added)`);
      }
    }
  }

  return {
    valid: errors.length === 0,
    errors,
    warnings,
  };
}

