# Platform Agent Task: Smart JSON Repair for Haiku

================================================================================
PRIORITY: LOW (OPTIONAL)
AGENT: Platform Agent
ESTIMATED TIME: 30-45 minutes
NOTE: Only needed if using `fast` tier extensively
================================================================================

## Governance Acknowledgment
Read AGENT_CONTEXT.md and follow all governance rules before proceeding.

## Context
Testing Agent documented that Haiku (`fast` tier) produces invalid outputs:
- Template names with parentheses: `"saas(auth+db)"` instead of `"saas"`
- Invalid enum values for categories, HTTP methods, layouts
- Current JSON repair handles extraction but not normalization

**Priority:** LOW - Only needed if `fast` tier is used extensively.

## Your Task
Enhance JSON repair to normalize enum values.

### Step 1: Review Current Implementation
```bash
cat packages/ai-agent/src/utils/json-repair.ts
```

### Step 2: Add Enum Normalization

File: `packages/ai-agent/src/utils/json-repair.ts`

Add these functions:

```typescript
/**
 * Valid enum values for schema fields
 */
const VALID_ENUMS = {
  template: ['saas', 'landing-page', 'dashboard', 'blog', 'directory', 'ecommerce'],
  category: ['saas', 'landing-page', 'dashboard', 'blog', 'directory', 'ecommerce'],
  complexity: ['simple', 'moderate', 'complex'],
  layout: ['default', 'dashboard', 'auth', 'minimal', 'full-width'],
  httpMethod: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  componentType: ['ui', 'feature', 'layout', 'page'],
};

/**
 * Normalize an enum value by extracting base identifier
 * "saas(auth+db)" → "saas"
 * "landing-page (marketing)" → "landing-page"
 */
function normalizeEnumValue(value: unknown, validValues: string[]): string {
  if (typeof value !== 'string') return validValues[0];
  
  // Extract base identifier before parentheses, brackets, or extra whitespace
  const base = value.split(/[\s([\]]/)[0].trim().toLowerCase();
  
  // Find exact match (case-insensitive)
  const match = validValues.find(v => v.toLowerCase() === base);
  if (match) return match;
  
  // Find partial match
  const partial = validValues.find(v => base.includes(v.toLowerCase()) || v.toLowerCase().includes(base));
  if (partial) return partial;
  
  // Default to first valid value
  return validValues[0];
}

/**
 * Normalize all enum fields in parsed JSON
 */
function normalizeEnums(data: Record<string, unknown>): Record<string, unknown> {
  const normalized = { ...data };
  
  // Top-level fields
  if ('suggestedTemplate' in normalized) {
    normalized.suggestedTemplate = normalizeEnumValue(normalized.suggestedTemplate, VALID_ENUMS.template);
  }
  if ('category' in normalized) {
    normalized.category = normalizeEnumValue(normalized.category, VALID_ENUMS.category);
  }
  if ('complexity' in normalized) {
    normalized.complexity = normalizeEnumValue(normalized.complexity, VALID_ENUMS.complexity);
  }
  
  // Nested arrays (pages, components, routes)
  if (Array.isArray(normalized.pages)) {
    normalized.pages = normalized.pages.map((page: Record<string, unknown>) => ({
      ...page,
      layout: page.layout ? normalizeEnumValue(page.layout, VALID_ENUMS.layout) : 'default',
    }));
  }
  
  if (Array.isArray(normalized.components)) {
    normalized.components = normalized.components.map((comp: Record<string, unknown>) => ({
      ...comp,
      type: comp.type ? normalizeEnumValue(comp.type, VALID_ENUMS.componentType) : 'ui',
    }));
  }
  
  if (Array.isArray(normalized.routes)) {
    normalized.routes = normalized.routes.map((route: Record<string, unknown>) => ({
      ...route,
      method: route.method ? normalizeEnumValue(route.method, VALID_ENUMS.httpMethod) : 'GET',
    }));
  }
  
  return normalized;
}
```

### Step 3: Integrate into repairAndParseJSON

Update the main function to call `normalizeEnums`:

```typescript
export function repairAndParseJSON(text: string): RepairResult {
  const repairs: string[] = [];
  
  // ... existing extraction logic ...
  
  try {
    let data = JSON.parse(jsonString);
    
    // NEW: Normalize enum values
    const originalData = JSON.stringify(data);
    data = normalizeEnums(data);
    if (JSON.stringify(data) !== originalData) {
      repairs.push('enum-normalization');
    }
    
    return {
      success: true,
      data,
      repaired: repairs.length > 0,
      repairs,
    };
  } catch (error) {
    // ... existing error handling ...
  }
}
```

### Step 4: Add Repair Metrics Export

Add to `token-tracker.ts`:

```typescript
interface RepairMetrics {
  enumNormalizations: number;
  jsonExtractions: number;
  truncationRepairs: number;
}

// Add to TokenTracker class
private repairMetrics: RepairMetrics = {
  enumNormalizations: 0,
  jsonExtractions: 0,
  truncationRepairs: 0,
};

recordRepair(type: keyof RepairMetrics): void {
  this.repairMetrics[type]++;
}

getRepairMetrics(): RepairMetrics {
  return { ...this.repairMetrics };
}
```

### Step 5: Build and Test
```bash
cd packages/ai-agent
npm run build
node test-mock.mjs
cd ../..
npm test
```

### Step 6: Test with Haiku (if API key available)
```bash
# Force fast tier to trigger repairs
node -e "
const { generateProject } = require('./packages/ai-agent/dist/index.js');
generateProject(
  { description: 'Simple todo app', projectName: 'TestRepair' },
  { modelTier: 'fast', logTokenUsage: true }
).then(r => console.log('Success:', r.intent.suggestedTemplate))
 .catch(e => console.log('Error:', e.message));
"
```

### Step 7: Update Memory and Commit
```bash
git add -A
git commit -m "feat(ai-agent): add enum normalization to JSON repair for Haiku reliability"
git push origin main
```

## Success Criteria
- [ ] Enum values normalized correctly
- [ ] Repairs logged when applied
- [ ] All 668 tests pass
- [ ] `fast` tier success rate improves (if tested with API)

================================================================================
END OF PROMPT
================================================================================

