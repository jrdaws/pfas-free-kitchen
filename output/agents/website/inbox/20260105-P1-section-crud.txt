Next Agent: Website Agent

Confirm you are the Website Agent.

---

# Task: Section CRUD & Real-time Preview Editing

## Priority: P1
## Estimated Time: 4-5 hours
## Dependencies: Composer Mode Toggle (completed)

---

## Context

Currently, composed previews are static. Users cannot:
- Reorder sections
- Add new sections
- Remove sections
- Duplicate sections
- Edit section content inline

**Goal**: Make the preview fully editable with real-time updates.

---

## Requirements

### 1. Composition State Management

**File**: `website/lib/stores/composition-store.ts`

```typescript
import { create } from 'zustand';
import type { ProjectComposition, SectionComposition, PageComposition } from '@/lib/composer/types';

interface CompositionState {
  composition: ProjectComposition | null;
  selectedPageId: string | null;
  selectedSectionIndex: number | null;
  
  // History for undo/redo
  history: ProjectComposition[];
  historyIndex: number;
  
  // Dirty tracking
  isDirty: boolean;
  lastSaved: Date | null;
  
  // Actions
  setComposition: (composition: ProjectComposition) => void;
  selectPage: (pageId: string) => void;
  selectSection: (pageId: string, sectionIndex: number) => void;
  
  // Section operations
  addSection: (pageId: string, section: SectionComposition, atIndex?: number) => void;
  removeSection: (pageId: string, sectionIndex: number) => void;
  moveSection: (pageId: string, fromIndex: number, toIndex: number) => void;
  duplicateSection: (pageId: string, sectionIndex: number) => void;
  updateSectionProps: (pageId: string, sectionIndex: number, props: Record<string, unknown>) => void;
  
  // Undo/redo
  undo: () => void;
  redo: () => void;
  canUndo: () => boolean;
  canRedo: () => boolean;
  
  // Save
  markSaved: () => void;
  reset: () => void;
}

const MAX_HISTORY = 20;

export const useCompositionStore = create<CompositionState>((set, get) => ({
  composition: null,
  selectedPageId: null,
  selectedSectionIndex: null,
  history: [],
  historyIndex: -1,
  isDirty: false,
  lastSaved: null,
  
  setComposition: (composition) => {
    const { history, historyIndex } = get();
    const newHistory = [...history.slice(0, historyIndex + 1), composition].slice(-MAX_HISTORY);
    set({
      composition,
      history: newHistory,
      historyIndex: newHistory.length - 1,
      isDirty: true,
    });
  },
  
  addSection: (pageId, section, atIndex) => {
    const { composition, setComposition } = get();
    if (!composition) return;
    
    const newComposition = {
      ...composition,
      pages: composition.pages.map(page => {
        if (page.pageId !== pageId) return page;
        
        const newSections = [...page.sections];
        const insertIndex = atIndex ?? newSections.length;
        newSections.splice(insertIndex, 0, { ...section, order: insertIndex });
        
        // Reorder all sections
        return {
          ...page,
          sections: newSections.map((s, i) => ({ ...s, order: i + 1 })),
        };
      }),
    };
    
    setComposition(newComposition);
  },
  
  removeSection: (pageId, sectionIndex) => {
    const { composition, setComposition } = get();
    if (!composition) return;
    
    const newComposition = {
      ...composition,
      pages: composition.pages.map(page => {
        if (page.pageId !== pageId) return page;
        return {
          ...page,
          sections: page.sections
            .filter((_, i) => i !== sectionIndex)
            .map((s, i) => ({ ...s, order: i + 1 })),
        };
      }),
    };
    
    setComposition(newComposition);
  },
  
  moveSection: (pageId, fromIndex, toIndex) => {
    const { composition, setComposition } = get();
    if (!composition) return;
    
    const newComposition = {
      ...composition,
      pages: composition.pages.map(page => {
        if (page.pageId !== pageId) return page;
        
        const newSections = [...page.sections];
        const [moved] = newSections.splice(fromIndex, 1);
        newSections.splice(toIndex, 0, moved);
        
        return {
          ...page,
          sections: newSections.map((s, i) => ({ ...s, order: i + 1 })),
        };
      }),
    };
    
    setComposition(newComposition);
  },
  
  // ... implement other methods
}));
```

---

### 2. Section Operations API

**File**: `website/app/api/compose/section/route.ts`

```typescript
// POST /api/compose/section/add
export async function POST(request: NextRequest) {
  const { pageId, patternId, atIndex, context } = await request.json();
  
  // Get pattern and generate props
  const pattern = getPatternById(patternId);
  const props = await generatePatternProps({ pattern, context, sectionIndex: atIndex });
  
  return NextResponse.json({
    success: true,
    section: {
      patternId,
      variant: 'dark',
      order: atIndex,
      props: props.props,
    },
  });
}
```

**File**: `website/app/api/compose/section/[id]/regenerate/route.ts`

```typescript
// POST /api/compose/section/[id]/regenerate
export async function POST(request: NextRequest, { params }: { params: { id: string } }) {
  const { composition, pageId, sectionIndex, feedback, context } = await request.json();
  
  const section = await regenerateSection(composition, pageId, sectionIndex, feedback, context);
  
  return NextResponse.json({
    success: true,
    section,
  });
}
```

---

### 3. UI Components

#### SectionToolbar

**File**: `website/app/components/preview/SectionToolbar.tsx`

Appears on hover over any section:

```tsx
interface SectionToolbarProps {
  pageId: string;
  sectionIndex: number;
  totalSections: number;
  onMoveUp: () => void;
  onMoveDown: () => void;
  onDuplicate: () => void;
  onDelete: () => void;
  onEdit: () => void;
  onRegenerate: () => void;
}

export function SectionToolbar({ ... }: SectionToolbarProps) {
  return (
    <div className="absolute top-2 right-2 flex items-center gap-1 bg-stone-900/90 backdrop-blur rounded-lg p-1 opacity-0 group-hover:opacity-100 transition-opacity">
      <TooltipProvider>
        <Tooltip>
          <TooltipTrigger asChild>
            <button onClick={onMoveUp} disabled={sectionIndex === 0}>
              <ChevronUp className="h-4 w-4" />
            </button>
          </TooltipTrigger>
          <TooltipContent>Move Up</TooltipContent>
        </Tooltip>
        
        {/* Similar buttons for: Move Down, Duplicate, Edit, Regenerate, Delete */}
      </TooltipProvider>
    </div>
  );
}
```

#### PatternPicker

**File**: `website/app/components/preview/PatternPicker.tsx`

Modal to browse and add patterns:

```tsx
interface PatternPickerProps {
  isOpen: boolean;
  onClose: () => void;
  onSelect: (patternId: string) => void;
}

export function PatternPicker({ isOpen, onClose, onSelect }: PatternPickerProps) {
  const patterns = getAvailablePatterns();
  const [category, setCategory] = useState<string>('all');
  const [search, setSearch] = useState('');
  
  const filtered = patterns.filter(p => 
    (category === 'all' || p.category === category) &&
    (p.name.toLowerCase().includes(search.toLowerCase()) || 
     p.tags.some(t => t.includes(search.toLowerCase())))
  );
  
  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-3xl">
        <DialogHeader>
          <DialogTitle>Add Section</DialogTitle>
        </DialogHeader>
        
        <div className="flex gap-4">
          {/* Category sidebar */}
          <div className="w-40 space-y-1">
            {CATEGORIES.map(cat => (
              <button 
                key={cat}
                onClick={() => setCategory(cat)}
                className={cn(
                  "w-full text-left px-3 py-2 rounded",
                  category === cat ? "bg-primary" : "hover:bg-muted"
                )}
              >
                {cat}
              </button>
            ))}
          </div>
          
          {/* Pattern grid */}
          <div className="flex-1">
            <Input 
              placeholder="Search patterns..."
              value={search}
              onChange={e => setSearch(e.target.value)}
            />
            
            <div className="grid grid-cols-2 gap-4 mt-4">
              {filtered.map(pattern => (
                <PatternCard 
                  key={pattern.id}
                  pattern={pattern}
                  onClick={() => onSelect(pattern.id)}
                />
              ))}
            </div>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
}
```

#### InlineEditor

**File**: `website/app/components/preview/InlineEditor.tsx`

Click text to edit:

```tsx
interface InlineEditorProps {
  value: string;
  onChange: (value: string) => void;
  tag?: 'h1' | 'h2' | 'h3' | 'p' | 'span';
  className?: string;
  editable?: boolean;
}

export function InlineEditor({ 
  value, 
  onChange, 
  tag = 'span',
  className,
  editable = true,
}: InlineEditorProps) {
  const [isEditing, setIsEditing] = useState(false);
  const [draft, setDraft] = useState(value);
  const inputRef = useRef<HTMLInputElement>(null);
  
  useEffect(() => {
    if (isEditing) {
      inputRef.current?.focus();
      inputRef.current?.select();
    }
  }, [isEditing]);
  
  const handleBlur = () => {
    setIsEditing(false);
    if (draft !== value) {
      onChange(draft);
    }
  };
  
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      handleBlur();
    } else if (e.key === 'Escape') {
      setDraft(value);
      setIsEditing(false);
    }
  };
  
  const Tag = tag;
  
  if (!editable) {
    return <Tag className={className}>{value}</Tag>;
  }
  
  if (isEditing) {
    return (
      <input
        ref={inputRef}
        value={draft}
        onChange={e => setDraft(e.target.value)}
        onBlur={handleBlur}
        onKeyDown={handleKeyDown}
        className={cn(
          "bg-transparent border-b border-primary outline-none w-full",
          className
        )}
      />
    );
  }
  
  return (
    <Tag 
      onClick={() => setIsEditing(true)}
      className={cn(
        className,
        "cursor-text hover:bg-primary/10 transition-colors rounded px-1 -mx-1"
      )}
    >
      {value}
    </Tag>
  );
}
```

#### PropEditor Sidebar

**File**: `website/app/components/preview/PropEditor.tsx`

Sidebar panel for editing all props of selected section:

```tsx
export function PropEditor() {
  const { composition, selectedPageId, selectedSectionIndex, updateSectionProps } = useCompositionStore();
  
  if (!composition || selectedPageId === null || selectedSectionIndex === null) {
    return (
      <div className="p-4 text-center text-muted-foreground">
        Select a section to edit its properties
      </div>
    );
  }
  
  const page = composition.pages.find(p => p.pageId === selectedPageId);
  const section = page?.sections[selectedSectionIndex];
  const pattern = getPatternById(section?.patternId || '');
  
  if (!section || !pattern) return null;
  
  return (
    <div className="p-4 space-y-4">
      <h3 className="font-semibold">{pattern.name}</h3>
      
      {pattern.slots.map(slot => (
        <div key={slot.name} className="space-y-1">
          <Label className="text-xs">{slot.name}</Label>
          <SlotEditor
            slot={slot}
            value={section.props[slot.name]}
            onChange={(value) => updateSectionProps(
              selectedPageId,
              selectedSectionIndex,
              { ...section.props, [slot.name]: value }
            )}
          />
        </div>
      ))}
    </div>
  );
}
```

---

### 4. Drag & Drop

Use `@dnd-kit/core` for section reordering:

```tsx
import { DndContext, closestCenter, DragEndEvent } from '@dnd-kit/core';
import { SortableContext, verticalListSortingStrategy } from '@dnd-kit/sortable';

export function EditablePreview() {
  const { composition, moveSection } = useCompositionStore();
  const sensors = useSensors(useSensor(PointerSensor));
  
  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    if (!over || active.id === over.id) return;
    
    const [pageId, fromIndexStr] = (active.id as string).split('-');
    const [, toIndexStr] = (over.id as string).split('-');
    
    moveSection(pageId, parseInt(fromIndexStr), parseInt(toIndexStr));
  };
  
  return (
    <DndContext sensors={sensors} collisionDetection={closestCenter} onDragEnd={handleDragEnd}>
      {composition?.pages.map(page => (
        <SortableContext 
          key={page.pageId}
          items={page.sections.map((_, i) => `${page.pageId}-${i}`)}
          strategy={verticalListSortingStrategy}
        >
          {page.sections.map((section, index) => (
            <SortableSection 
              key={`${page.pageId}-${index}`}
              id={`${page.pageId}-${index}`}
              section={section}
              pageId={page.pageId}
              index={index}
            />
          ))}
        </SortableContext>
      ))}
    </DndContext>
  );
}
```

---

## Dependencies to Install

```bash
npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
```

---

## Testing Requirements

1. **Manual Testing**:
   - Add section → Section appears at correct position
   - Remove section → Section is removed, others reorder
   - Move section → Drag and drop works smoothly
   - Duplicate section → Creates copy with same props
   - Edit text → Inline editing saves correctly
   - Undo/Redo → History navigation works

2. **Edge Cases**:
   - Only one section → Delete disabled
   - Move to same position → No-op
   - Rapid operations → No race conditions

---

## Acceptance Criteria

- [x] Zustand store manages composition state
- [x] Undo/redo works with 20-step history
- [x] SectionToolbar appears on hover
- [x] PatternPicker shows all patterns
- [x] Inline text editing works
- [x] Drag and drop reorders sections
- [x] API endpoints for section operations work
- [x] Build passes with no errors

## Completion Notes (2026-01-05)

Task completed. See handoff document at:
`output/agents/website/outbox/20260105-section-crud-complete.md`

---

## Output Files

1. `website/lib/stores/composition-store.ts`
2. `website/app/api/compose/section/route.ts`
3. `website/app/api/compose/section/[id]/regenerate/route.ts`
4. `website/app/components/preview/SectionToolbar.tsx`
5. `website/app/components/preview/PatternPicker.tsx`
6. `website/app/components/preview/InlineEditor.tsx`
7. `website/app/components/preview/PropEditor.tsx`
8. `website/app/components/preview/EditablePreview.tsx`
9. Updated: `website/app/components/preview/ComposedPreview.tsx`

---

## Handoff

When complete, create file:
`output/agents/website/outbox/20260105-section-crud-complete.md`

Include:
- Component usage examples
- Store API documentation
- Integration with LivePreviewPanel

