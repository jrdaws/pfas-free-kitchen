# TASK: Click-to-Edit Functionality in Preview

**Priority**: P0
**Wave**: 2 (After Wave 1)
**Assigned To**: Website Agent
**Estimated Effort**: 4-5 hours
**Dependencies**: WAVE1-B-viewport-switching.txt

---

## Objective

Enable users to click on any text element in the preview to edit it inline. This is the core WYSIWYG experience that makes the preview "premium."

---

## Current State

- SectionRenderer has `editable` prop passed through
- BasePatternProps includes `onEdit` callback
- No actual inline editing implemented

---

## Implementation Architecture

### 1. EditableText Component

**File**: `website/components/preview/EditableText.tsx`

```tsx
'use client';

import { useState, useRef, useEffect } from 'react';

interface EditableTextProps {
  value: string;
  onChange: (newValue: string) => void;
  as?: 'h1' | 'h2' | 'h3' | 'p' | 'span';
  className?: string;
  placeholder?: string;
  editable?: boolean;
}

export function EditableText({
  value,
  onChange,
  as: Component = 'span',
  className = '',
  placeholder = 'Click to edit...',
  editable = true,
}: EditableTextProps) {
  const [isEditing, setIsEditing] = useState(false);
  const [editValue, setEditValue] = useState(value);
  const inputRef = useRef<HTMLTextAreaElement>(null);

  useEffect(() => {
    if (isEditing && inputRef.current) {
      inputRef.current.focus();
      inputRef.current.select();
    }
  }, [isEditing]);

  useEffect(() => {
    setEditValue(value);
  }, [value]);

  if (!editable) {
    return <Component className={className}>{value || placeholder}</Component>;
  }

  if (isEditing) {
    return (
      <textarea
        ref={inputRef}
        value={editValue}
        onChange={(e) => setEditValue(e.target.value)}
        onBlur={() => {
          setIsEditing(false);
          if (editValue !== value) {
            onChange(editValue);
          }
        }}
        onKeyDown={(e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            setIsEditing(false);
            onChange(editValue);
          }
          if (e.key === 'Escape') {
            setIsEditing(false);
            setEditValue(value);
          }
        }}
        className={`${className} bg-transparent border-2 border-orange-500 rounded resize-none outline-none w-full`}
        style={{
          minHeight: '1.5em',
          height: 'auto',
        }}
      />
    );
  }

  return (
    <Component
      className={`${className} cursor-text hover:outline hover:outline-2 hover:outline-orange-500/50 hover:outline-offset-2 transition-all`}
      onClick={() => setIsEditing(true)}
      title="Click to edit"
    >
      {value || <span className="opacity-50">{placeholder}</span>}
    </Component>
  );
}
```

### 2. EditableWrapper (for complex elements)

**File**: `website/components/preview/EditableWrapper.tsx`

```tsx
'use client';

import { useState } from 'react';

interface EditableWrapperProps {
  children: React.ReactNode;
  editable?: boolean;
  onHover?: () => void;
  onClick?: () => void;
  label?: string;
}

export function EditableWrapper({
  children,
  editable = true,
  onHover,
  onClick,
  label,
}: EditableWrapperProps) {
  const [isHovered, setIsHovered] = useState(false);

  if (!editable) {
    return <>{children}</>;
  }

  return (
    <div
      className="relative group"
      onMouseEnter={() => {
        setIsHovered(true);
        onHover?.();
      }}
      onMouseLeave={() => setIsHovered(false)}
    >
      {isHovered && (
        <>
          {/* Highlight outline */}
          <div className="absolute inset-0 border-2 border-orange-500/50 rounded-lg pointer-events-none z-10" />
          
          {/* Label badge */}
          {label && (
            <div className="absolute -top-6 left-2 px-2 py-0.5 bg-orange-500 text-white text-xs rounded z-20">
              {label}
            </div>
          )}
          
          {/* Edit button */}
          <button
            onClick={onClick}
            className="absolute top-2 right-2 p-1.5 bg-orange-500 hover:bg-orange-600 text-white rounded z-20"
          >
            <svg className="w-4 h-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
            </svg>
          </button>
        </>
      )}
      {children}
    </div>
  );
}
```

### 3. Update Pattern Components

Update each pattern to use EditableText. Example for HeroCenteredGradient:

**File**: `website/lib/patterns/patterns/heroes/centered-gradient.tsx`

```tsx
import { EditableText } from '@/components/preview/EditableText';

export function HeroCenteredGradient({
  headline,
  subheadline,
  editable = false,
  onEdit,
  // ... rest
}: HeroPatternProps) {
  
  const handleEdit = (field: string, value: string) => {
    onEdit?.({ [field]: value });
  };

  return (
    <section className="...">
      <div className="...">
        <EditableText
          value={headline || 'Your Headline Here'}
          onChange={(v) => handleEdit('headline', v)}
          as="h1"
          className="text-5xl font-bold text-white"
          editable={editable}
        />
        
        <EditableText
          value={subheadline || 'Your subheadline goes here'}
          onChange={(v) => handleEdit('subheadline', v)}
          as="p"
          className="text-xl text-white/80 mt-4"
          editable={editable}
        />
        
        {/* CTA buttons - use EditableWrapper for complex items */}
        <EditableWrapper 
          editable={editable} 
          label="Primary CTA"
          onClick={() => openCTAEditor('primary')}
        >
          <button className="...">{primaryCTA?.label || 'Get Started'}</button>
        </EditableWrapper>
      </div>
    </section>
  );
}
```

### 4. Props Editor Modal

For complex props (buttons, lists, images), show a modal:

**File**: `website/components/preview/PropsEditorModal.tsx`

```tsx
'use client';

import { useState } from 'react';

interface PropsEditorModalProps {
  isOpen: boolean;
  onClose: () => void;
  title: string;
  fields: Array<{
    key: string;
    label: string;
    type: 'text' | 'url' | 'color' | 'image' | 'select';
    value: any;
    options?: { value: string; label: string }[];
  }>;
  onSave: (values: Record<string, any>) => void;
}

export function PropsEditorModal({
  isOpen,
  onClose,
  title,
  fields,
  onSave,
}: PropsEditorModalProps) {
  const [values, setValues] = useState<Record<string, any>>(
    Object.fromEntries(fields.map((f) => [f.key, f.value]))
  );

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50">
      <div className="bg-slate-900 rounded-xl p-6 w-full max-w-md border border-white/10">
        <h3 className="text-lg font-semibold text-white mb-4">{title}</h3>
        
        <div className="space-y-4">
          {fields.map((field) => (
            <div key={field.key}>
              <label className="text-sm text-white/60">{field.label}</label>
              {field.type === 'text' || field.type === 'url' ? (
                <input
                  type={field.type}
                  value={values[field.key] || ''}
                  onChange={(e) => setValues({ ...values, [field.key]: e.target.value })}
                  className="w-full mt-1 px-3 py-2 bg-slate-800 border border-white/10 rounded-lg text-white"
                />
              ) : field.type === 'select' ? (
                <select
                  value={values[field.key] || ''}
                  onChange={(e) => setValues({ ...values, [field.key]: e.target.value })}
                  className="w-full mt-1 px-3 py-2 bg-slate-800 border border-white/10 rounded-lg text-white"
                >
                  {field.options?.map((opt) => (
                    <option key={opt.value} value={opt.value}>{opt.label}</option>
                  ))}
                </select>
              ) : null}
            </div>
          ))}
        </div>

        <div className="flex justify-end gap-3 mt-6">
          <button
            onClick={onClose}
            className="px-4 py-2 text-white/60 hover:text-white"
          >
            Cancel
          </button>
          <button
            onClick={() => {
              onSave(values);
              onClose();
            }}
            className="px-4 py-2 bg-orange-500 hover:bg-orange-600 text-white rounded-lg"
          >
            Save Changes
          </button>
        </div>
      </div>
    </div>
  );
}
```

### 5. Wire Up to SectionRenderer

**File**: `website/components/preview/SectionRenderer.tsx`

Update to pass edit handlers and propagate changes:

```tsx
export function SectionRenderer({
  section,
  definition,
  onSectionChange,
  editable = false,
}: SectionRendererProps) {
  
  const handlePropEdit = (updates: Record<string, any>) => {
    if (!onSectionChange) return;
    
    onSectionChange({
      ...section,
      props: {
        ...section.props,
        ...updates,
      },
    });
  };

  // Merge props
  const finalProps = {
    ...getDefaultProps(section.patternId),
    ...section.props,
    editable,
    onEdit: handlePropEdit,
  };

  const Component = COMPONENT_MAP[section.patternId];
  if (!Component) return <UnknownPattern patternId={section.patternId} />;

  return <Component {...finalProps} />;
}
```

---

## Editable Elements by Pattern

| Pattern | Editable Elements |
|---------|-------------------|
| HeroCenteredGradient | headline, subheadline, primaryCTA, secondaryCTA |
| HeroSplitImage | headline, description, CTA |
| FeaturesIconGrid | title, subtitle, each feature title/description |
| FeaturesBentoGrid | each feature title/description |
| TestimonialCards | each quote, author name, role |
| LogoWall | headline |
| PricingTable3Tier | each tier name, price, description, features |
| CTASection | headline, subheadline, button text |
| FAQAccordion | each question and answer |

---

## Success Criteria

- [ ] Clicking any text shows edit indicator
- [ ] Text becomes editable input on click
- [ ] Enter saves, Escape cancels
- [ ] Changes persist in definition
- [ ] Complex items (buttons, lists) open modal editor
- [ ] Hover shows element boundary and label
- [ ] Smooth animations on all interactions

---

## UX Details

1. **Hover State**: Light outline + small label showing what element is
2. **Active State**: Orange border, text becomes input
3. **Saving**: Subtle pulse animation on save
4. **Undo**: Cmd+Z should undo last change (stretch goal)

---

## Testing

1. Enable editable mode in preview
2. Click on hero headline - should become editable
3. Type new text, press Enter - should save
4. Check that definition state reflects change
5. Refresh page - changes should persist (if using state management)

---

*Created by Documentation Agent*

