# TASK: Undo/Redo History for Preview Edits

**Priority**: P1
**Wave**: 4 (After Wave 3)
**Assigned To**: Website Agent
**Estimated Effort**: 3 hours
**Dependencies**: WAVE2-A-click-to-edit-preview.txt

---

## Objective

Implement undo/redo functionality for all preview edits. Users should be able to press Cmd+Z to undo and Cmd+Shift+Z to redo changes they've made to the preview.

---

## Current State

- Changes update definition state directly
- No history tracking
- No way to revert changes

---

## Implementation

### 1. History Hook

**File**: `website/hooks/useHistory.ts`

```typescript
'use client';

import { useState, useCallback, useRef, useEffect } from 'react';

interface HistoryState<T> {
  past: T[];
  present: T;
  future: T[];
}

interface UseHistoryReturn<T> {
  state: T;
  setState: (newState: T | ((prev: T) => T)) => void;
  undo: () => void;
  redo: () => void;
  canUndo: boolean;
  canRedo: boolean;
  reset: (newState: T) => void;
  clear: () => void;
  historyLength: number;
}

export function useHistory<T>(
  initialState: T,
  maxHistory: number = 50
): UseHistoryReturn<T> {
  const [history, setHistory] = useState<HistoryState<T>>({
    past: [],
    present: initialState,
    future: [],
  });

  // Track if we should skip next change (for external updates)
  const skipRef = useRef(false);

  const setState = useCallback(
    (newState: T | ((prev: T) => T)) => {
      if (skipRef.current) {
        skipRef.current = false;
        return;
      }

      setHistory((prev) => {
        const resolvedState =
          typeof newState === 'function'
            ? (newState as (prev: T) => T)(prev.present)
            : newState;

        // Don't add to history if nothing changed
        if (JSON.stringify(resolvedState) === JSON.stringify(prev.present)) {
          return prev;
        }

        // Limit past history size
        const newPast = [...prev.past, prev.present].slice(-maxHistory);

        return {
          past: newPast,
          present: resolvedState,
          future: [], // Clear future on new change
        };
      });
    },
    [maxHistory]
  );

  const undo = useCallback(() => {
    setHistory((prev) => {
      if (prev.past.length === 0) return prev;

      const newPast = prev.past.slice(0, -1);
      const newPresent = prev.past[prev.past.length - 1];

      return {
        past: newPast,
        present: newPresent,
        future: [prev.present, ...prev.future],
      };
    });
  }, []);

  const redo = useCallback(() => {
    setHistory((prev) => {
      if (prev.future.length === 0) return prev;

      const [newPresent, ...newFuture] = prev.future;

      return {
        past: [...prev.past, prev.present],
        present: newPresent,
        future: newFuture,
      };
    });
  }, []);

  const reset = useCallback((newState: T) => {
    setHistory({
      past: [],
      present: newState,
      future: [],
    });
  }, []);

  const clear = useCallback(() => {
    setHistory((prev) => ({
      past: [],
      present: prev.present,
      future: [],
    }));
  }, []);

  return {
    state: history.present,
    setState,
    undo,
    redo,
    canUndo: history.past.length > 0,
    canRedo: history.future.length > 0,
    reset,
    clear,
    historyLength: history.past.length + history.future.length + 1,
  };
}
```

### 2. Keyboard Shortcuts Hook

**File**: `website/hooks/useUndoRedoShortcuts.ts`

```typescript
'use client';

import { useEffect } from 'react';

interface UseUndoRedoShortcutsOptions {
  undo: () => void;
  redo: () => void;
  canUndo: boolean;
  canRedo: boolean;
  enabled?: boolean;
}

export function useUndoRedoShortcuts({
  undo,
  redo,
  canUndo,
  canRedo,
  enabled = true,
}: UseUndoRedoShortcutsOptions) {
  useEffect(() => {
    if (!enabled) return;

    const handleKeyDown = (e: KeyboardEvent) => {
      // Skip if user is typing in an input
      if (
        e.target instanceof HTMLInputElement ||
        e.target instanceof HTMLTextAreaElement
      ) {
        return;
      }

      const isMac = navigator.platform.toUpperCase().includes('MAC');
      const modKey = isMac ? e.metaKey : e.ctrlKey;

      if (modKey && e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        if (canUndo) undo();
      }

      if (modKey && e.key === 'z' && e.shiftKey) {
        e.preventDefault();
        if (canRedo) redo();
      }

      // Also support Ctrl+Y for redo on Windows
      if (e.ctrlKey && e.key === 'y') {
        e.preventDefault();
        if (canRedo) redo();
      }
    };

    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [undo, redo, canUndo, canRedo, enabled]);
}
```

### 3. History UI Component

**File**: `website/components/preview/HistoryControls.tsx`

```tsx
'use client';

interface HistoryControlsProps {
  canUndo: boolean;
  canRedo: boolean;
  onUndo: () => void;
  onRedo: () => void;
  historyLength: number;
}

export function HistoryControls({
  canUndo,
  canRedo,
  onUndo,
  onRedo,
  historyLength,
}: HistoryControlsProps) {
  return (
    <div className="flex items-center gap-1 bg-slate-800 rounded-lg p-1">
      <button
        onClick={onUndo}
        disabled={!canUndo}
        className="p-2 rounded hover:bg-slate-700 disabled:opacity-30 disabled:cursor-not-allowed"
        title="Undo (Cmd+Z)"
      >
        <UndoIcon className="w-4 h-4 text-white" />
      </button>
      <button
        onClick={onRedo}
        disabled={!canRedo}
        className="p-2 rounded hover:bg-slate-700 disabled:opacity-30 disabled:cursor-not-allowed"
        title="Redo (Cmd+Shift+Z)"
      >
        <RedoIcon className="w-4 h-4 text-white" />
      </button>
      {historyLength > 1 && (
        <span className="px-2 text-xs text-white/40">
          {historyLength} changes
        </span>
      )}
    </div>
  );
}

function UndoIcon({ className }: { className?: string }) {
  return (
    <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
        d="M3 10h10a5 5 0 015 5v2M3 10l4-4m-4 4l4 4" />
    </svg>
  );
}

function RedoIcon({ className }: { className?: string }) {
  return (
    <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
        d="M21 10h-10a5 5 0 00-5 5v2M21 10l-4-4m4 4l-4 4" />
    </svg>
  );
}
```

### 4. Integrate with LivePreviewPanel

**File**: Update `website/components/configurator/LivePreviewPanel.tsx`

```tsx
import { useHistory } from '@/hooks/useHistory';
import { useUndoRedoShortcuts } from '@/hooks/useUndoRedoShortcuts';
import { HistoryControls } from '@/components/preview/HistoryControls';

export function LivePreviewPanel({
  initialDefinition,
  onDefinitionChange,
  // ...
}: LivePreviewPanelProps) {
  // Use history for undo/redo
  const {
    state: definition,
    setState: setDefinition,
    undo,
    redo,
    canUndo,
    canRedo,
    historyLength,
  } = useHistory(initialDefinition);

  // Enable keyboard shortcuts
  useUndoRedoShortcuts({ undo, redo, canUndo, canRedo, enabled: editable });

  // Sync changes back to parent
  useEffect(() => {
    onDefinitionChange?.(definition);
  }, [definition, onDefinitionChange]);

  return (
    <div className="...">
      <header className="...">
        {/* Existing buttons */}

        {editable && (
          <HistoryControls
            canUndo={canUndo}
            canRedo={canRedo}
            onUndo={undo}
            onRedo={redo}
            historyLength={historyLength}
          />
        )}

        {/* More buttons */}
      </header>

      <DynamicPreviewRenderer
        definition={definition}
        onDefinitionChange={setDefinition}
        editable={editable}
      />
    </div>
  );
}
```

---

## Debounced Changes

For text editing, debounce changes to avoid cluttering history:

```typescript
import { useDebouncedCallback } from 'use-debounce';

// In EditableText component
const debouncedSave = useDebouncedCallback((value: string) => {
  onChange(value);
}, 500);
```

This batches rapid keystrokes into single history entries.

---

## History Snapshots

Consider saving named snapshots:

```typescript
interface HistorySnapshot {
  id: string;
  name: string;
  timestamp: number;
  state: ProjectDefinition;
}

// User can save: "After hero edit", "Before colors change", etc.
```

This is a stretch goal for post-MVP.

---

## Success Criteria

- [ ] Cmd+Z undoes last change
- [ ] Cmd+Shift+Z redoes undone change
- [ ] Undo/Redo buttons in toolbar
- [ ] Buttons disabled when nothing to undo/redo
- [ ] History cleared on project reset
- [ ] Typing debounced to avoid history spam
- [ ] Works across all edit types (text, patterns, branding)

---

## Testing

1. Edit hero headline
2. Press Cmd+Z - headline reverts
3. Press Cmd+Shift+Z - edit restored
4. Make 5 changes
5. Undo 3 times
6. Redo 2 times
7. Make new change - future history cleared

---

*Created by Documentation Agent*

