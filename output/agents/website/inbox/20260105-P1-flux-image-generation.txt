TASK: Integrate Flux Image Generation via Replicate
PRIORITY: P1 (Phase 3 of Visual Matching)
TYPE: Backend / Frontend / API
AGENT: Website Agent
PARALLEL: Yes - After research fix is done

---

## Objective

Add AI image generation using Flux (via Replicate) to generate:
- Hero images matching the project's style
- Product/feature images
- Team photos
- Background patterns

## Prerequisites

User needs to add to Vercel:
```
REPLICATE_API_TOKEN=r8_xxxxxxxxxxxxx
```

Get token from: https://replicate.com/account/api-tokens

## Implementation

### 1. Install Replicate SDK

```bash
cd website && npm install replicate
```

### 2. Create Image Generation API

```typescript
// website/app/api/generate/image/route.ts

import { NextRequest, NextResponse } from "next/server";
import Replicate from "replicate";

const replicate = new Replicate({
  auth: process.env.REPLICATE_API_TOKEN,
});

interface ImageGenerationRequest {
  prompt: string;
  style?: "photorealistic" | "illustration" | "minimal" | "abstract";
  aspectRatio?: "1:1" | "16:9" | "9:16" | "4:3";
  colorPalette?: string[];  // Hex colors to incorporate
}

export async function POST(request: NextRequest) {
  const { prompt, style, aspectRatio, colorPalette } = await request.json();
  
  // Build enhanced prompt
  const enhancedPrompt = buildEnhancedPrompt(prompt, style, colorPalette);
  
  // Determine dimensions
  const { width, height } = getAspectRatioDimensions(aspectRatio || "16:9");
  
  try {
    const output = await replicate.run(
      "black-forest-labs/flux-schnell",  // Fast model
      // Or use "black-forest-labs/flux-1.1-pro" for higher quality
      {
        input: {
          prompt: enhancedPrompt,
          width,
          height,
          num_outputs: 1,
          output_format: "webp",
          output_quality: 90,
        },
      }
    );
    
    // Output is an array of image URLs
    const imageUrl = Array.isArray(output) ? output[0] : output;
    
    return NextResponse.json({
      success: true,
      imageUrl,
    });
  } catch (error) {
    console.error("Image generation failed:", error);
    return NextResponse.json(
      { success: false, error: "Image generation failed" },
      { status: 500 }
    );
  }
}

function buildEnhancedPrompt(
  basePrompt: string,
  style?: string,
  colorPalette?: string[]
): string {
  let prompt = basePrompt;
  
  // Add style modifiers
  const styleModifiers: Record<string, string> = {
    photorealistic: "professional photography, 8k, high detail, sharp focus",
    illustration: "modern flat illustration, vector art style, clean lines",
    minimal: "minimalist design, clean, simple, elegant",
    abstract: "abstract shapes, geometric patterns, modern art",
  };
  
  if (style && styleModifiers[style]) {
    prompt += `, ${styleModifiers[style]}`;
  }
  
  // Add color guidance
  if (colorPalette && colorPalette.length > 0) {
    prompt += `, color palette: ${colorPalette.join(", ")}`;
  }
  
  // Quality boosters
  prompt += ", high quality, professional";
  
  return prompt;
}

function getAspectRatioDimensions(ratio: string): { width: number; height: number } {
  const dimensions: Record<string, { width: number; height: number }> = {
    "1:1": { width: 1024, height: 1024 },
    "16:9": { width: 1344, height: 768 },
    "9:16": { width: 768, height: 1344 },
    "4:3": { width: 1152, height: 896 },
  };
  return dimensions[ratio] || dimensions["16:9"];
}
```

### 3. Create Image Generation Hook

```typescript
// website/hooks/useImageGeneration.ts

import { useState } from "react";

interface UseImageGenerationOptions {
  onSuccess?: (imageUrl: string) => void;
  onError?: (error: string) => void;
}

export function useImageGeneration(options: UseImageGenerationOptions = {}) {
  const [isGenerating, setIsGenerating] = useState(false);
  const [generatedImage, setGeneratedImage] = useState<string | null>(null);
  
  const generateImage = async (params: {
    prompt: string;
    style?: "photorealistic" | "illustration" | "minimal" | "abstract";
    aspectRatio?: "1:1" | "16:9" | "9:16" | "4:3";
    colorPalette?: string[];
  }) => {
    setIsGenerating(true);
    
    try {
      const response = await fetch("/api/generate/image", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(params),
      });
      
      const data = await response.json();
      
      if (data.success && data.imageUrl) {
        setGeneratedImage(data.imageUrl);
        options.onSuccess?.(data.imageUrl);
        return data.imageUrl;
      } else {
        throw new Error(data.error || "Generation failed");
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      options.onError?.(message);
      throw error;
    } finally {
      setIsGenerating(false);
    }
  };
  
  return {
    generateImage,
    isGenerating,
    generatedImage,
  };
}
```

### 4. Integrate with Preview

Generate images for preview components:

```typescript
// website/lib/composer/prop-generator.ts

async function generatePatternProps(input: PropGeneratorInput) {
  const { pattern, context } = input;
  
  // Generate text props with AI
  const textProps = await generateTextProps(pattern, context);
  
  // Check if pattern needs images
  const imageSlots = pattern.slots.filter(s => s.type === "image");
  
  if (imageSlots.length > 0 && context.preferences?.generateImages) {
    const imagePrompts = buildImagePrompts(pattern, context);
    
    for (const slot of imageSlots) {
      const prompt = imagePrompts[slot.name];
      if (prompt) {
        const imageUrl = await generateImage({
          prompt,
          style: context.design?.aesthetic?.overall || "modern",
          colorPalette: context.colors ? Object.values(context.colors) : undefined,
        });
        textProps[slot.name] = imageUrl;
      }
    }
  }
  
  return { props: textProps, generatedImages: imageSlots.length };
}

function buildImagePrompts(
  pattern: Pattern,
  context: ComposerInput
): Record<string, string> {
  const { vision, research } = context;
  
  const prompts: Record<string, string> = {};
  
  // Hero image
  if (pattern.id.includes("hero")) {
    prompts.image = `Hero image for ${vision.projectName}, ${vision.description}, professional website header`;
  }
  
  // Product images
  if (pattern.id.includes("product")) {
    prompts.productImage = `Product showcase for ${vision.projectName}, clean product photography`;
  }
  
  // Feature illustrations
  if (pattern.id.includes("feature")) {
    prompts.illustration = `Feature illustration, modern tech, ${vision.description}`;
  }
  
  return prompts;
}
```

### 5. Add Generate Images Toggle

In preview panel, add option to generate images:

```tsx
// In LivePreviewPanel.tsx

<div className="flex items-center gap-2">
  <label className="text-xs">
    <input
      type="checkbox"
      checked={generateImages}
      onChange={(e) => setGenerateImages(e.target.checked)}
    />
    Generate AI Images
  </label>
</div>
```

### 6. Image Caching

Cache generated images to avoid re-generating:

```typescript
// website/lib/image-cache.ts

const IMAGE_CACHE = new Map<string, string>();

export function getCachedImage(promptHash: string): string | undefined {
  return IMAGE_CACHE.get(promptHash);
}

export function cacheImage(promptHash: string, url: string): void {
  IMAGE_CACHE.set(promptHash, url);
}

function hashPrompt(prompt: string): string {
  // Simple hash for prompt
  return btoa(prompt).substring(0, 20);
}
```

## Files to Create

1. `website/app/api/generate/image/route.ts` (new)
2. `website/hooks/useImageGeneration.ts` (new)
3. `website/lib/image-cache.ts` (new)

## Files to Modify

1. `website/package.json` - Add replicate dependency
2. `website/lib/composer/prop-generator.ts` - Add image generation
3. `website/app/components/configurator/LivePreviewPanel.tsx` - Add toggle

## Environment Variables

```
REPLICATE_API_TOKEN=r8_xxxxxxxxxxxxxxxx
```

## Success Criteria

- [ ] Replicate SDK installed
- [ ] Image generation API works
- [ ] Hook provides loading state
- [ ] Preview shows generated images
- [ ] Images match project style/colors
- [ ] Caching prevents duplicate generations

