# TASK: Drag-and-Drop Section Reordering

**Priority**: P1
**Wave**: 2 (After Wave 1)
**Assigned To**: Website Agent
**Estimated Effort**: 3-4 hours
**Dependencies**: WAVE2-B-pattern-swapping-ui.txt

---

## Objective

Enable users to reorder sections by dragging and dropping them in the preview. This provides a more intuitive way to rearrange page layout than up/down buttons.

---

## Current State

- Sections render in order from definition
- No drag-and-drop functionality
- WAVE2-B adds up/down buttons as fallback

---

## Implementation Options

### Option A: @dnd-kit/core (Recommended)

Lightweight, accessible, React-focused drag-and-drop library.

**Install**:
```bash
npm install @dnd-kit/core @dnd-kit/sortable @dnd-kit/utilities
```

### Option B: react-beautiful-dnd

More opinionated, heavier bundle, but simpler API.

### Option C: Native HTML5 Drag-and-Drop

No dependencies, but less smooth and harder to customize.

---

## Implementation with @dnd-kit

### 1. Create DraggableSectionList

**File**: `website/components/preview/DraggableSectionList.tsx`

```tsx
'use client';

import { useState } from 'react';
import {
  DndContext,
  closestCenter,
  KeyboardSensor,
  PointerSensor,
  useSensor,
  useSensors,
  DragEndEvent,
  DragOverlay,
  DragStartEvent,
} from '@dnd-kit/core';
import {
  arrayMove,
  SortableContext,
  sortableKeyboardCoordinates,
  verticalListSortingStrategy,
} from '@dnd-kit/sortable';
import { SortableSection } from './SortableSection';
import { SectionRenderer } from './SectionRenderer';
import type { SectionConfig, ProjectDefinition } from '@/lib/patterns/types';

interface DraggableSectionListProps {
  sections: SectionConfig[];
  definition: ProjectDefinition;
  editable?: boolean;
  onSectionsChange: (sections: SectionConfig[]) => void;
  onSectionChange: (index: number, section: SectionConfig) => void;
  onSectionDelete: (index: number) => void;
}

export function DraggableSectionList({
  sections,
  definition,
  editable = false,
  onSectionsChange,
  onSectionChange,
  onSectionDelete,
}: DraggableSectionListProps) {
  const [activeId, setActiveId] = useState<string | null>(null);

  const sensors = useSensors(
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8, // 8px movement before drag starts
      },
    }),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates,
    })
  );

  const handleDragStart = (event: DragStartEvent) => {
    setActiveId(event.active.id as string);
  };

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    setActiveId(null);

    if (over && active.id !== over.id) {
      const oldIndex = sections.findIndex((s) => s.id === active.id);
      const newIndex = sections.findIndex((s) => s.id === over.id);

      const reordered = arrayMove(sections, oldIndex, newIndex);
      onSectionsChange(reordered);
    }
  };

  const activeSection = activeId
    ? sections.find((s) => s.id === activeId)
    : null;

  if (!editable) {
    // Non-editable mode: just render sections
    return (
      <>
        {sections.map((section, index) => (
          <SectionRenderer
            key={section.id}
            section={section}
            index={index}
            totalSections={sections.length}
            definition={definition}
            editable={false}
          />
        ))}
      </>
    );
  }

  return (
    <DndContext
      sensors={sensors}
      collisionDetection={closestCenter}
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
    >
      <SortableContext
        items={sections.map((s) => s.id)}
        strategy={verticalListSortingStrategy}
      >
        {sections.map((section, index) => (
          <SortableSection
            key={section.id}
            section={section}
            index={index}
            totalSections={sections.length}
            definition={definition}
            onSectionChange={(s) => onSectionChange(index, s)}
            onSectionDelete={() => onSectionDelete(index)}
          />
        ))}
      </SortableContext>

      {/* Drag overlay - shows dragged section preview */}
      <DragOverlay>
        {activeSection && (
          <div className="opacity-80 shadow-2xl rounded-xl overflow-hidden pointer-events-none">
            <SectionRenderer
              section={activeSection}
              index={0}
              totalSections={1}
              definition={definition}
              editable={false}
            />
          </div>
        )}
      </DragOverlay>
    </DndContext>
  );
}
```

### 2. Create SortableSection Wrapper

**File**: `website/components/preview/SortableSection.tsx`

```tsx
'use client';

import { useSortable } from '@dnd-kit/sortable';
import { CSS } from '@dnd-kit/utilities';
import { SectionRenderer } from './SectionRenderer';
import type { SectionConfig, ProjectDefinition } from '@/lib/patterns/types';

interface SortableSectionProps {
  section: SectionConfig;
  index: number;
  totalSections: number;
  definition: ProjectDefinition;
  onSectionChange: (section: SectionConfig) => void;
  onSectionDelete: () => void;
}

export function SortableSection({
  section,
  index,
  totalSections,
  definition,
  onSectionChange,
  onSectionDelete,
}: SortableSectionProps) {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    transition,
    isDragging,
  } = useSortable({ id: section.id });

  const style = {
    transform: CSS.Transform.toString(transform),
    transition,
    opacity: isDragging ? 0.5 : 1,
    zIndex: isDragging ? 50 : 'auto',
  };

  return (
    <div ref={setNodeRef} style={style}>
      <SectionRenderer
        section={section}
        index={index}
        totalSections={totalSections}
        definition={definition}
        editable={true}
        onSectionChange={onSectionChange}
        onSectionDelete={onSectionDelete}
        dragHandleProps={{ ...attributes, ...listeners }}
      />
    </div>
  );
}
```

### 3. Add Drag Handle to SectionToolbar

Update toolbar to include drag handle:

**File**: `website/components/preview/SectionToolbar.tsx`

```tsx
export function SectionToolbar({
  section,
  dragHandleProps,
  // ... other props
}: SectionToolbarProps) {
  return (
    <div className="...">
      {/* Drag handle - first item */}
      <button
        {...dragHandleProps}
        className="p-1.5 cursor-grab active:cursor-grabbing hover:bg-white/5 rounded"
        title="Drag to reorder"
      >
        <GripVerticalIcon className="w-4 h-4 text-white" />
      </button>

      <div className="w-px h-6 bg-white/10" />

      {/* Rest of toolbar... */}
    </div>
  );
}

function GripVerticalIcon({ className }: { className?: string }) {
  return (
    <svg className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2}
        d="M8 6h.01M8 12h.01M8 18h.01M16 6h.01M16 12h.01M16 18h.01" />
    </svg>
  );
}
```

### 4. Add Drop Zone Indicators

Show where section will drop:

```tsx
// In DraggableSectionList
{sections.map((section, index) => (
  <React.Fragment key={section.id}>
    {/* Drop zone indicator */}
    <DropIndicator 
      isOver={isOverIndex === index}
      position="before"
    />
    
    <SortableSection ... />
    
    {index === sections.length - 1 && (
      <DropIndicator 
        isOver={isOverIndex === sections.length}
        position="after"
      />
    )}
  </React.Fragment>
))}

function DropIndicator({ isOver, position }: { isOver: boolean; position: 'before' | 'after' }) {
  return (
    <div
      className={`h-1 mx-4 rounded-full transition-all ${
        isOver ? 'bg-orange-500 scale-y-[3]' : 'bg-transparent'
      }`}
    />
  );
}
```

---

## Keyboard Accessibility

The @dnd-kit library supports keyboard navigation:
- **Space/Enter**: Pick up item
- **Arrow keys**: Move item
- **Space/Enter**: Drop item
- **Escape**: Cancel drag

Ensure focus styles are visible:

```css
[data-dnd-kit-active="true"] {
  outline: 2px solid var(--color-orange-500);
  outline-offset: 2px;
}
```

---

## Success Criteria

- [ ] Sections can be dragged to reorder
- [ ] Smooth animation during drag
- [ ] Drop indicator shows target position
- [ ] Keyboard navigation works (Space to pick up, arrows to move)
- [ ] Order persists after drop
- [ ] Works with viewport switching

---

## Performance Considerations

- Use `useMemo` for static section content
- Limit drag preview complexity (simplified version)
- Throttle position updates if needed
- Ensure smooth 60fps during drag

---

## Testing

1. Enable editable mode
2. Grab drag handle on section
3. Drag up/down - see indicators
4. Drop in new position - order changes
5. Test with 5+ sections
6. Test keyboard navigation

---

*Created by Documentation Agent*

