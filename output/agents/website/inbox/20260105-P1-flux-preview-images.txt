TASK: Generate Preview Images with Flux Based on Analysis
PRIORITY: P1 (After Wave 2)
TYPE: Frontend / AI Images
AGENT: Website Agent
PARALLEL: No - Wave 2.5 (After Analysis, Before Final Preview)

---

## Objective

Use the analyzed website structure to generate custom images for the preview
using Flux (Replicate) that match the inspiration site's style.

---

## Context

We now have:
- Extracted color palette from inspiration
- Detected layout patterns (hero with image, feature cards, etc.)
- Component styles (image treatment: rounded, masked, etc.)
- Content context (project vision, audience, tone)

Use this to generate RELEVANT images, not generic stock photos.

---

## Implementation

### 1. Smart Image Prompt Builder

```typescript
// website/lib/image-prompt-builder.ts

interface ImageContext {
  section: 'hero' | 'features' | 'testimonials' | 'product';
  purpose: string;  // e.g., "hero background", "feature icon", "team member"
  style: {
    colorPalette: string[];
    imageStyle: 'photorealistic' | 'illustration' | 'abstract' | '3d';
    mood: 'professional' | 'friendly' | 'luxurious' | 'playful';
  };
  content: {
    projectName: string;
    industry: string;
    audience: string;
  };
}

export function buildImagePrompt(context: ImageContext): string {
  const { section, purpose, style, content } = context;
  
  // Base prompt by section type
  const sectionPrompts: Record<string, string> = {
    hero: `${content.industry} themed hero image for ${content.projectName}`,
    features: `Icon or illustration representing a key feature`,
    testimonials: `Professional headshot of a ${content.audience} persona`,
    product: `Product showcase image in ${style.mood} style`,
  };
  
  let prompt = sectionPrompts[section] || purpose;
  
  // Add style modifiers
  const styleModifiers: Record<string, string> = {
    photorealistic: 'professional photography, 8k, high detail, shallow depth of field',
    illustration: 'modern flat illustration, vector art, clean lines',
    abstract: 'abstract shapes, geometric patterns, gradients',
    '3d': '3D render, isometric, modern, clean',
  };
  
  prompt += `, ${styleModifiers[style.imageStyle] || styleModifiers.photorealistic}`;
  
  // Add color palette
  if (style.colorPalette.length > 0) {
    prompt += `, color scheme: ${style.colorPalette.join(', ')}`;
  }
  
  // Add mood
  const moodModifiers: Record<string, string> = {
    professional: 'corporate, trustworthy, sophisticated',
    friendly: 'warm, approachable, inviting',
    luxurious: 'elegant, premium, exclusive',
    playful: 'fun, energetic, colorful',
  };
  
  prompt += `, ${moodModifiers[style.mood] || 'professional'}`;
  
  // Quality suffix
  prompt += ', high quality, trending on artstation';
  
  return prompt;
}
```

### 2. Batch Image Generation for Preview

```typescript
// website/lib/preview-image-generator.ts

import { buildImagePrompt } from './image-prompt-builder';

interface PreviewImageRequest {
  sections: {
    type: string;
    needsImage: boolean;
    imageSlot?: 'hero' | 'background' | 'icon' | 'avatar';
  }[];
  websiteAnalysis: WebsiteAnalysis;
  vision: {
    projectName: string;
    description: string;
    audience: string;
    tone: string;
  };
}

export async function generatePreviewImages(
  request: PreviewImageRequest
): Promise<Map<string, string>> {
  const { sections, websiteAnalysis, vision } = request;
  const images = new Map<string, string>();
  
  // Determine style from analysis
  const style = {
    colorPalette: [
      websiteAnalysis.visual.colorPalette.primary,
      websiteAnalysis.visual.colorPalette.accent,
    ],
    imageStyle: inferImageStyle(websiteAnalysis),
    mood: vision.tone as 'professional' | 'friendly' | 'luxurious' | 'playful',
  };
  
  // Generate images for sections that need them
  for (const section of sections) {
    if (section.needsImage) {
      const prompt = buildImagePrompt({
        section: section.type as any,
        purpose: `${section.imageSlot} image for ${section.type} section`,
        style,
        content: {
          projectName: vision.projectName,
          industry: extractIndustry(vision.description),
          audience: vision.audience,
        },
      });
      
      try {
        const imageUrl = await generateFluxImage(prompt, section.imageSlot);
        images.set(`${section.type}-${section.imageSlot}`, imageUrl);
      } catch (error) {
        console.error(`Failed to generate image for ${section.type}:`, error);
        // Use placeholder on failure
        images.set(`${section.type}-${section.imageSlot}`, '/placeholder.jpg');
      }
    }
  }
  
  return images;
}

function inferImageStyle(analysis: WebsiteAnalysis): string {
  // Infer from detected components
  const { components } = analysis.visual;
  
  if (components.icons.style === 'duotone' || components.icons.style === 'line') {
    return 'illustration';
  }
  if (components.cards.style === 'glass') {
    return '3d';
  }
  return 'photorealistic';
}

async function generateFluxImage(
  prompt: string,
  slot: string
): Promise<string> {
  const aspectRatio = getAspectRatioForSlot(slot);
  
  const response = await fetch('/api/generate/image', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      prompt,
      style: 'photorealistic', // Or inferred style
      aspectRatio,
    }),
  });
  
  const data = await response.json();
  return data.imageUrl;
}

function getAspectRatioForSlot(slot: string): string {
  const ratios: Record<string, string> = {
    hero: '16:9',
    background: '16:9',
    icon: '1:1',
    avatar: '1:1',
    feature: '4:3',
  };
  return ratios[slot] || '16:9';
}
```

### 3. Integrate with Preview Renderer

```typescript
// website/components/preview/PreviewWithImages.tsx

export function PreviewWithImages({ 
  composition, 
  websiteAnalysis,
  vision 
}: Props) {
  const [images, setImages] = useState<Map<string, string>>(new Map());
  const [isGenerating, setIsGenerating] = useState(false);
  
  const generateImages = async () => {
    setIsGenerating(true);
    
    const sectionsNeedingImages = composition.pages.map(page => ({
      type: page.patternId,
      needsImage: page.config?.hasImage || page.slots?.some(s => s.type === 'image'),
      imageSlot: inferImageSlot(page),
    }));
    
    const generatedImages = await generatePreviewImages({
      sections: sectionsNeedingImages,
      websiteAnalysis,
      vision,
    });
    
    setImages(generatedImages);
    setIsGenerating(false);
  };
  
  return (
    <div className="preview">
      <button onClick={generateImages} disabled={isGenerating}>
        {isGenerating ? 'Generating...' : 'Generate Custom Images'}
      </button>
      
      {composition.pages.map((page, index) => (
        <PreviewSection
          key={index}
          pattern={page}
          customImage={images.get(`${page.patternId}-hero`) || images.get(`${page.patternId}-background`)}
        />
      ))}
    </div>
  );
}
```

### 4. Image Caching

Don't regenerate images unnecessarily:

```typescript
// website/lib/image-cache.ts

interface CachedImage {
  promptHash: string;
  url: string;
  generatedAt: string;
}

export class PreviewImageCache {
  private cache = new Map<string, CachedImage>();
  
  getImage(prompt: string): string | null {
    const hash = this.hashPrompt(prompt);
    const cached = this.cache.get(hash);
    
    if (cached) {
      // Check if still valid (not older than 1 hour)
      const age = Date.now() - new Date(cached.generatedAt).getTime();
      if (age < 3600000) {
        return cached.url;
      }
    }
    return null;
  }
  
  setImage(prompt: string, url: string): void {
    const hash = this.hashPrompt(prompt);
    this.cache.set(hash, {
      promptHash: hash,
      url,
      generatedAt: new Date().toISOString(),
    });
  }
  
  private hashPrompt(prompt: string): string {
    return btoa(prompt).substring(0, 32);
  }
}
```

---

## Files to Create

1. `website/lib/image-prompt-builder.ts`
2. `website/lib/preview-image-generator.ts`
3. `website/components/preview/PreviewWithImages.tsx`

## Files to Modify

1. `website/components/preview/ComposedPreview.tsx` - Use PreviewWithImages
2. `website/lib/image-cache.ts` - Enhance existing cache

---

## Success Criteria

- [ ] Images generated match inspiration site's style
- [ ] Color palette applied to image prompts
- [ ] Appropriate aspect ratios used per section
- [ ] Caching prevents unnecessary regeneration
- [ ] Loading states shown during generation

