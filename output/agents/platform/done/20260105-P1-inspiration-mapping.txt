Next Agent: Platform Agent

Confirm you are the Platform Agent.

---

# Task: Inspiration → Layout Mapping System

## Priority: P1
## Estimated Time: 4-5 hours
## Dependencies: Pattern Expansion (Template Agent)

---

## Context

We already analyze inspiration websites (via Firecrawl), but we don't use the structural data to inform composition. Currently, website analysis only extracts text and basic metadata.

**Goal**: Detect the section structure of inspiration sites and map them to our pattern library, then use this to compose similar layouts.

---

## Requirements

### 1. Section Detector

**File**: `website/lib/inspiration/section-detector.ts`

Analyze HTML/screenshots to identify page sections:

```typescript
export interface DetectedSection {
  type: SectionType;             // 'hero' | 'features' | 'pricing' | etc.
  order: number;                 // Position on page (1-based)
  heightRatio: number;           // Approximate height (0-1 of viewport)
  hasImage: boolean;
  hasVideo: boolean;
  columnCount?: number;          // For grids
  textContent?: string;          // Key text snippets
  confidence: number;            // 0-1
}

export type SectionType = 
  | 'hero' | 'features' | 'pricing' | 'testimonials' | 'faq'
  | 'cta' | 'footer' | 'navigation' | 'stats' | 'team'
  | 'blog' | 'product' | 'how-it-works' | 'integrations' | 'unknown';

export async function detectSections(
  content: {
    html?: string;
    screenshot?: string;  // Base64 or URL
    url: string;
  }
): Promise<DetectedSection[]> {
  // Use Claude Vision if screenshot provided
  // Fall back to HTML parsing if only HTML
}
```

**HTML Parsing Heuristics**:
```typescript
const SECTION_INDICATORS = {
  hero: ['hero', 'banner', 'welcome', 'h1', 'landing'],
  features: ['features', 'benefits', 'capabilities', 'why-'],
  pricing: ['pricing', 'plans', 'price', 'tier', 'subscription'],
  testimonials: ['testimonials', 'reviews', 'customers', 'quotes'],
  faq: ['faq', 'questions', 'help', 'accordion'],
  cta: ['cta', 'signup', 'get-started', 'trial'],
  footer: ['footer', 'site-footer'],
  stats: ['stats', 'numbers', 'metrics', 'achievements'],
  team: ['team', 'about-us', 'people', 'leadership'],
};

function detectFromHTML(html: string): DetectedSection[] {
  // Parse DOM structure
  // Look for semantic elements: <section>, <header>, <footer>
  // Check class names against indicators
  // Estimate order from DOM position
  // Check for images/videos
}
```

**Vision Analysis (Claude)**:
```typescript
async function detectFromScreenshot(imageUrl: string): Promise<DetectedSection[]> {
  const response = await anthropic.messages.create({
    model: "claude-3-5-sonnet-20241022",
    messages: [{
      role: "user",
      content: [
        {
          type: "image",
          source: { type: "url", url: imageUrl }
        },
        {
          type: "text",
          text: `Analyze this webpage screenshot and identify all distinct sections.

For each section, provide:
1. Type (hero, features, pricing, testimonials, cta, footer, etc.)
2. Position from top (order number)
3. Approximate height ratio (0-1 of full page)
4. Whether it contains images
5. Whether it contains video
6. Number of columns if grid layout
7. Confidence (0-1)

Return JSON array of sections.`
        }
      ]
    }]
  });
  
  return parseVisionResponse(response);
}
```

---

### 2. Pattern Matcher

**File**: `website/lib/inspiration/pattern-matcher.ts`

Map detected sections to our pattern library:

```typescript
export interface PatternMapping {
  sectionIndex: number;          // Which detected section
  patternId: string;             // Our pattern ID
  variant: string;               // dark, light, etc.
  confidence: number;            // 0-1
  alternativePatterns: string[]; // Other possible matches
  source: 'exact' | 'similar' | 'fallback';
}

export function matchSectionsToPatterns(
  sections: DetectedSection[],
  patterns: Pattern[]
): PatternMapping[] {
  const mappings: PatternMapping[] = [];
  
  for (const [index, section] of sections.entries()) {
    const mapping = findBestPattern(section, patterns);
    mappings.push({
      sectionIndex: index,
      ...mapping,
    });
  }
  
  return mappings;
}

function findBestPattern(
  section: DetectedSection,
  patterns: Pattern[]
): Omit<PatternMapping, 'sectionIndex'> {
  // Filter patterns by category
  const categoryPatterns = patterns.filter(p => p.category === section.type);
  
  if (categoryPatterns.length === 0) {
    return { patternId: 'unknown', variant: 'dark', confidence: 0, alternativePatterns: [], source: 'fallback' };
  }
  
  // Score each pattern based on:
  // - Tag matches
  // - Has image if section has image
  // - Column count match
  // - inspirationSources includes the URL
  
  const scored = categoryPatterns.map(pattern => ({
    pattern,
    score: calculatePatternScore(section, pattern),
  }));
  
  scored.sort((a, b) => b.score - a.score);
  
  return {
    patternId: scored[0].pattern.id,
    variant: determineVariant(section),
    confidence: scored[0].score,
    alternativePatterns: scored.slice(1, 4).map(s => s.pattern.id),
    source: scored[0].score > 0.8 ? 'exact' : 'similar',
  };
}
```

---

### 3. Style Extractor

**File**: `website/lib/inspiration/style-extractor.ts`

Extract visual style from inspiration site:

```typescript
export interface ExtractedStyles {
  colors: {
    primary: string;           // Dominant brand color
    secondary: string;
    accent: string;
    background: string;
    text: string;
    confidence: number;
  };
  typography: {
    headingFont: string;       // Detected or "sans-serif"
    bodyFont: string;
    headingSizes: {
      h1: string;
      h2: string;
      h3: string;
    };
    confidence: number;
  };
  spacing: {
    sectionPadding: string;    // e.g., "6rem"
    elementGap: string;        // e.g., "2rem"
    confidence: number;
  };
  borderRadius: 'none' | 'sm' | 'md' | 'lg' | 'full';
  shadows: 'none' | 'subtle' | 'medium' | 'dramatic';
  animations: 'none' | 'subtle' | 'rich';
}

export async function extractStyles(
  content: {
    html?: string;
    css?: string;
    screenshot?: string;
    url: string;
  }
): Promise<ExtractedStyles> {
  // CSS parsing for color/typography extraction
  // Vision analysis for layout/spacing estimation
  // Combine results with confidence weighting
}

function extractColorsFromCSS(css: string): ExtractedStyles['colors'] {
  // Parse CSS variables
  // Look for --primary, --secondary, --background, etc.
  // Analyze most-used colors
  // Use color frequency analysis
}

function extractTypographyFromCSS(css: string): ExtractedStyles['typography'] {
  // Parse font-family declarations
  // Extract font sizes for headings
  // Identify Google Fonts or system fonts
}
```

---

### 4. Layout Composer

**File**: `website/lib/inspiration/layout-composer.ts`

Combine all analysis into composition-ready data:

```typescript
export interface InspirationComposition {
  sections: PatternMapping[];
  styles: ExtractedStyles;
  layout: {
    type: 'marketing' | 'dashboard' | 'blog' | 'ecommerce';
    navigation: 'fixed' | 'transparent' | 'sidebar';
    contentWidth: 'narrow' | 'standard' | 'wide' | 'full';
  };
  metadata: {
    sourceUrl: string;
    analysisTime: number;
    overallConfidence: number;
  };
}

export async function composeFromInspiration(
  inspirationUrls: string[],
  patterns: Pattern[]
): Promise<InspirationComposition> {
  // Analyze each URL
  const analyses = await Promise.all(
    inspirationUrls.map(url => analyzeInspiration(url))
  );
  
  // Merge/prioritize results
  const merged = mergeAnalyses(analyses);
  
  // Match to patterns
  const sections = matchSectionsToPatterns(merged.sections, patterns);
  
  return {
    sections,
    styles: merged.styles,
    layout: inferLayout(merged),
    metadata: {
      sourceUrl: inspirationUrls[0],
      analysisTime: Date.now(),
      overallConfidence: calculateOverallConfidence(sections, merged.styles),
    },
  };
}

function mergeAnalyses(analyses: AnalysisResult[]): MergedAnalysis {
  // Weight by recency (first URL = primary)
  // Average confidence scores
  // Combine unique sections
  // Prefer primary URL's styles
}
```

---

### 5. Integration with Composer

Update `website/lib/composer/selector.ts` to use inspiration data:

```typescript
export async function selectPatterns(input: SelectorInput): Promise<SelectorOutput> {
  // NEW: If inspiration composition is provided, use it
  if (input.inspirationComposition?.sections?.length) {
    console.log("[Selector] Using inspiration-driven pattern selection");
    return selectFromInspiration(input.inspirationComposition, input.pageType);
  }
  
  // Existing: design analysis
  if (input.designAnalysis?.patternRecommendations?.length) {
    return selectFromDesignAnalysis(input.designAnalysis, input.pageType);
  }
  
  // Fallback: AI selection or defaults
  // ... existing code
}

function selectFromInspiration(
  composition: InspirationComposition,
  pageType: PageType
): SelectorOutput {
  return {
    sections: composition.sections.map(s => ({
      patternId: s.patternId,
      reason: `Matched from inspiration site (${s.source}, ${Math.round(s.confidence * 100)}% confidence)`,
      variant: s.variant,
      order: s.sectionIndex + 1,
      confidenceScore: Math.round(s.confidence * 100),
    })),
    layoutRecommendation: mapLayoutType(composition.layout.type),
  };
}
```

---

## Output Files

1. `website/lib/inspiration/types.ts`
2. `website/lib/inspiration/section-detector.ts`
3. `website/lib/inspiration/pattern-matcher.ts`
4. `website/lib/inspiration/style-extractor.ts`
5. `website/lib/inspiration/layout-composer.ts`
6. `website/lib/inspiration/index.ts`
7. Updated: `website/lib/composer/selector.ts`

---

## Testing Requirements

1. **Manual Testing**:
   - Test with stripe.com → Should detect hero, features, pricing, footer
   - Test with linear.app → Should detect hero, bento features, CTA
   - Test with shopify.com → Should detect ecommerce patterns

2. **Unit Tests**:
   - HTML parsing correctly identifies sections
   - Pattern matching scores correctly
   - Style extraction parses CSS variables

---

## Acceptance Criteria

- [ ] Section detector identifies 5+ section types
- [ ] Pattern matcher maps to existing patterns
- [ ] Style extractor pulls colors and fonts
- [ ] Layout composer produces valid composition
- [ ] Selector uses inspiration when available
- [ ] Fallback works when inspiration analysis fails
- [ ] Build passes with no errors

---

## Handoff

When complete, create file:
`output/agents/platform/outbox/20260105-inspiration-mapping-complete.md`

Include:
- Architecture diagram
- Example output for 2 inspiration sites
- Integration instructions for Website Agent

