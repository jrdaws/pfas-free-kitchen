TASK: Test Pattern Composition System
PRIORITY: P1 (After Wave 2)
TYPE: Testing / Integration
AGENT: Quality Agent
PARALLEL: No - Wave 3

---

## Objective

Create comprehensive tests for the modular pattern composition system
to ensure reliable, high-quality output.

## Test Categories

### 1. Pattern Registry Tests

```typescript
// tests/patterns/registry.test.ts

describe('Pattern Registry', () => {
  it('loads all registered patterns', () => {
    const patterns = getAllPatterns();
    expect(patterns.length).toBeGreaterThan(20);
  });
  
  it('each pattern has required metadata', () => {
    getAllPatterns().forEach(pattern => {
      expect(pattern.id).toBeDefined();
      expect(pattern.name).toBeDefined();
      expect(pattern.slots).toBeInstanceOf(Array);
      expect(pattern.component).toBeDefined();
    });
  });
  
  it('pattern components are valid React components', () => {
    getAllPatterns().forEach(pattern => {
      const Component = loadPatternComponent(pattern.id);
      expect(typeof Component).toBe('function');
    });
  });
});
```

### 2. Composer Tests

```typescript
// tests/composer/composer.test.ts

describe('AI Composer', () => {
  it('selects appropriate patterns for SaaS project', async () => {
    const input = createMockSaaSInput();
    const result = await composeProject(input);
    
    expect(result.pages.length).toBeGreaterThan(0);
    expect(result.pages[0].sections.length).toBeGreaterThan(0);
    
    // Should include hero, features, pricing for SaaS
    const patternIds = result.pages[0].sections.map(s => s.patternId);
    expect(patternIds).toContain(expect.stringMatching(/hero/));
  });
  
  it('generates personalized props', async () => {
    const input = {
      ...createMockInput(),
      vision: { problem: 'Help developers ship faster' }
    };
    
    const result = await composeProject(input);
    const heroSection = result.pages[0].sections[0];
    
    // Props should mention developer/shipping, not generic text
    expect(heroSection.props.headline).toMatch(/developer|ship/i);
  });
  
  it('provides reasoning for each selection', async () => {
    const result = await composeProject(createMockInput());
    
    expect(result.reasoning).toBeDefined();
    expect(result.reasoning.length).toBeGreaterThan(0);
    result.reasoning.forEach(r => {
      expect(r.patternId).toBeDefined();
      expect(r.reason.length).toBeGreaterThan(10);
    });
  });
});
```

### 3. Pattern Rendering Tests

```typescript
// tests/patterns/rendering.test.ts

describe('Pattern Rendering', () => {
  getAllPatterns().forEach(pattern => {
    describe(pattern.id, () => {
      it('renders without errors', () => {
        const Component = loadPatternComponent(pattern.id);
        const exampleProps = loadExampleProps(pattern.id, 'saas');
        
        expect(() => {
          render(<Component {...exampleProps} />);
        }).not.toThrow();
      });
      
      it('renders with all variants', () => {
        const Component = loadPatternComponent(pattern.id);
        const exampleProps = loadExampleProps(pattern.id, 'saas');
        
        pattern.variants.forEach(variant => {
          expect(() => {
            render(<Component {...exampleProps} variant={variant} />);
          }).not.toThrow();
        });
      });
      
      it('handles missing optional slots gracefully', () => {
        const Component = loadPatternComponent(pattern.id);
        const minimalProps = getRequiredPropsOnly(pattern);
        
        expect(() => {
          render(<Component {...minimalProps} />);
        }).not.toThrow();
      });
    });
  });
});
```

### 4. Composition Validity Tests

```typescript
// tests/composer/validity.test.ts

describe('Composition Validity', () => {
  it('all pattern IDs in composition exist in registry', async () => {
    const result = await composeProject(createMockInput());
    
    result.pages.forEach(page => {
      page.sections.forEach(section => {
        expect(patternExists(section.patternId)).toBe(true);
      });
    });
  });
  
  it('all props match pattern slot requirements', async () => {
    const result = await composeProject(createMockInput());
    
    result.pages.forEach(page => {
      page.sections.forEach(section => {
        const pattern = getPattern(section.patternId);
        const requiredSlots = pattern.slots.filter(s => s.required);
        
        requiredSlots.forEach(slot => {
          expect(section.props[slot.name]).toBeDefined();
        });
      });
    });
  });
});
```

### 5. Export Integration Tests

```typescript
// tests/export/composition-export.test.ts

describe('Composition Export', () => {
  it('exported project matches composition structure', async () => {
    const composition = await composeProject(createMockInput());
    const exported = await exportProject({ composition });
    
    // Check that pages exist
    composition.pages.forEach(page => {
      const pagePath = `app${page.path}/page.tsx`;
      expect(exported.files[pagePath]).toBeDefined();
    });
  });
  
  it('exported components use correct patterns', async () => {
    const composition = await composeProject(createMockInput());
    const exported = await exportProject({ composition });
    
    // Check that pattern imports are present
    const homePageContent = exported.files['app/page.tsx'];
    composition.pages[0].sections.forEach(section => {
      expect(homePageContent).toContain(section.patternId);
    });
  });
});
```

## Success Criteria

- [ ] Registry tests pass
- [ ] Composer tests pass
- [ ] All patterns render
- [ ] Compositions are valid
- [ ] Export matches composition
- [ ] No regressions

## File Locations

```
tests/patterns/
├── registry.test.ts
├── rendering.test.ts
└── fixtures/

tests/composer/
├── composer.test.ts
├── validity.test.ts
└── mocks/

tests/export/
└── composition-export.test.ts
```

